# Завжди використовуйте об'єктно-орієнтоване програмування. #

> Проблема об'єктно-орієнтованих мов у тому, що вони тягнуть за собою все, що з ними пов'язано. Ви хотіли банан, а отримали мавпу, яка його тримає, і ще всі джунглі на додачу.
>
> -- Джо Армстронг у [«Кодери за роботою - Роздуми про ремесло програмування»](http://codersatwork.com/)

> Абстракція - велика сила. А що в мене викликає алергію ще з 1990-х, то це CORBA, COM, DCOM і всяка об'єктно-орієнтована нісенітниця. Кожен новий проєкт у той час обов'язково мав якусь примочку, якій було потрібно 200 000 викликів тільки для того, щоб надрукувати Hello World. Це профанація. Справжні програмісти таким не займаються.
>
> -- Брендан Айк у [«Кодери за роботою - Роздуми про ремесло програмування»](http://codersatwork.com/)

Багато розробників програмного забезпечення і багато компаній вважають, що об'єктно-орієнтоване програмування сьогодні є єдиним розумним способом розробки. Той, хто виступить проти нього, одразу ж усвідомлює той факт, що він сперечається проти «традиційної мудрості».

На блогах і форумах з програмування є дуже багато людей, які відстоюють ООП, і які впевнені, що знають, про що говорять. І це попри відсутність будь-якого чіткого його визначення!

Річ у тому, що так зване об'єктне програмування часто стає важким тягарем через непотрібну складність!

Як комп'ютерні теоретики і програмісти ми повинні навчитися спростовувати упередження і знаходити найкращі рішення для поставленого завдання.

На сьогодні однією з основних переваг PHP є підтримка обох імперативних, функціональної, об'єктно-орієнтованої, процедурної та рефлексивної парадигм. PHP є величезним набором інструментів з великою кількістю різних механізмів, які дають змогу розв'язати багато проблем по-різному, не тільки одним шляхом.

** Щойно ми починаємо нав'язувати різні внутрішні проблеми додатка одній специфічній парадигмі, ми перестаємо думати творчо, перестаємо працювати ефективно.**

## Невеликий урок історії. ##

Один із найкращих способів зрозуміти специфічну парадигму програмування - подивитися на її еволюцію. Що стало причиною для її розвитку? Які проблеми, наявні в інших парадигмах, призвели до нового способу мислення? Чи була це реальна світова проблема, чи вона була академічною? І як ця парадигма відтоді змінилася?

Не має значення, що говорить людина X, і яке визначення дає людина Y. Важлива історія виникнення парадигм.

> Є два способи побудови програм. Перший - зробити її настільки простою, що в ній очевидно не буде недоліків. Другий - зробити її такою складною, що в ній не буде очевидних недоліків.
>
> -- [Чарльз Ентонi Рiчард Хоар](https://en.wikiquote.org/wiki/C._A._R._Hoare)

У минулому, ще до пришестя об'єктно-орієнтованих мов, приблизно наприкінці п'ятдесятих, було створено безліч програм із використанням неструктурованого програмування. Їх іноді називають мовами першого і другого поколінь. Неструктуроване програмування історично є найбільш ранньою парадигмою. Її сильно критикували за спагетті-код.

Існують як високорівневі, так і низькорівневі мови, які використовують неструктуроване програмування. До них належать ранні версії BASIC, COBOL, MUMPS, JOSS, FOCAL, TELCOMP, машинний код, ранні асемблерні системи (без процедурних метаоператорів) і деякі скриптові мови.

Програма в неструктурованих мовах, як правило, складається з послідовних команд і операторів по одному в кожному рядку. Рядки зазвичай нумеруються або мають мітки, що дозволяють потоку переходити до будь-якого рядка в програмі (наприклад, за допомогою непопулярного оператора GOTO).


У шістдесяті роки структурне програмування з'явилося переважно завдяки відомій статті Едсгера Дейкстри [«Докази проти оператора GOTO»](http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html)

Структурне програмування - це парадигма, яка покращує ясність, якість і результат розроблення програмного забезпечення шляхом використання підпрограм, блокових структур і циклів. На відміну від використання елементарних відгалужень програми, таких як оператор GOTO.

Пізніше зі структурного програмування виникло процедурне. Воно засноване на концепції «виклику процедур». А це просто інша назва «виклику функцій». Процедури так само відомі як підпрограми або методи. Процедура просто містить низку обчислювальних кроків, які мають бути виконані. Будь-яка процедура може бути викликана в будь-який момент під час виконання програми, зокрема й іншими процедурами або навіть собою.

Спочатку всі процедури були доступні з будь-якої частини програми як глобальні дані. У невеликих програмах це не було проблемою, але, як тільки програма ускладнювалася, і її розмір збільшувався, невеликі зміни в одній частині програми стали значною мірою впливати на багато інших частин.

Жоден не планував таких змін і появи такої кількості залежностей. Невелика зміна в одній процедурі могла призвести до низки помилок у багатьох інших процедурах, що залежать від її вихідного коду.

Нова технологія розвивалася, що дало змогу розділити дані на різні області видимості, які називаються «об'єктами». Тільки конкретні процедури, що належать до однієї області видимості, могли отримати доступ до даних тієї ж області. Це називається приховування даних або інкапсуляція. Результатом стала набагато краща організація коду.

Спочатку об'єкти не називали об'єктами, їх розглядали тільки як області видимості. Пізніше, коли залежності та зв'язки між змінними і процедурами всередині цих областей зменшилися, їх стали розглядати як окремі ізольовані сегменти. У результаті народилися такі поняття, як об'єкти та об'єктно-орієнтоване програмування.

Ще пізніше, здебільшого завдяки розвитку Java, з'явилися деякі "слівця", процедури і функції перестали називатися функціями, а стали називатися методами, якщо вони перебували всередині меж об'єкта. Змінні теж більше не називають «змінними», їх було перейменовано в «атрибути», якщо вони перебували в окремій області видимості.

Таким чином, об'єкт, по суті, це просто набір функцій і змінних, які тепер стали називатися «методами та атрибутами».

Методи та атрибути ізольовані всередині окремої області за допомогою використання «класу». Після створення екземпляра класу він називається об'єктом.

Об'єкти можуть один на одного посилатися, і за допомогою цих посилань методи (функції) всередині можуть «спілкуватися» мiж собою. Об'єкти також можуть «переймати» методи від інших об'єктів, тим самим їх розширюючи. Це називається «наслідуванням». Це спосіб повторного використання коду, що дає змогу створювати незалежні розширення програм через публічні класи та інтерфейси. Взаємозв'язки об'єктів призводять до ієрархії. Спадкування було винайдено 1967 року для мови програмування [Simula 67](http://en.wikipedia.org/wiki/Simula).

Об'єкти можуть так само успадковувати методи від інших об'єктів і «перевизначити» їх із додаванням або зміною функціональних можливостей. Це називається «поліморфізм».

Ці в різних мовах програмування ці ідеї реалізовано різними способами.

Об'єктно-орієнтоване програмування - це зовсім інший спосіб організації коду, ніж був раніше. Це продовження процедурного програмування з додаванням приховування даних (інкапсуляції) та уникненням глобальних областей видимості. Йдеться про розширення функцій шляхом "запозичення" своїх схем без впливу на вихідний код (успадкування). І йдеться про перевизначення функцій, при якому не зачіпається вихідний код (поліморфізм).

> Об'єктно-орієнтована модель дає змогу легко нарощувати програми за рахунок акреції. На практиці це, як правило, означає, що вона забезпечує структурований спосіб запису спагетті-коду.
>
> -- Пол Грем у [Ansi Common Lisp](https://openlibrary.org/works/OL7944696W/ANSI_Common_Lisp)

**Неправильний шлях**: Завжди використовувати об'єктно-орієнтоване програмування. ![Thumbs down](/img/thumbs-down.png)
